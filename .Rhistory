The final element is a data frame giving the weights to pass to the evaluation stage to form a synthetic marker as a weighted, standardised sum of the markers screened as significant in the screening stage. We give a couple of different options for how to specify these weights. The default option, specified by setting \code{weight.mode = "inverse.delta"} in \code{rise.screen()}, sets the weights as the inverse of the estimated delta values. Let's have a look at the weights given by the function
#' @author Arthur Hughes
#'
#' @examples
#' # Load high-dimensional example data
# data("example.data.highdim")
# yone <- example.data.highdim$y1
# yzero <- example.data.highdim$y0
# sone <- example.data.highdim$s1
# szero <- example.data.highdim$s0
# rise.screen.result <- rise.screen(yone, yzero, sone, szero, power.want.s = 0.8)
rise.screen <- function(yone,
yzero,
sone,
szero,
alpha = 0.05,
power.want.s = NULL,
epsilon = NULL,
u.y.hyp = NULL,
p.correction = "BH",
n.cores = 1,
alternative = "less",
paired = FALSE,
return.all.screen = TRUE,
return.all.weights = FALSE,
weight.mode = "inverse.delta",
normalise.weights = T) {
# Data formatting
## Convert dataframes to numeric matrices
if (is.data.frame(sone) | is.data.frame(szero)) {
sone <- as.matrix(sone)
szero <- as.matrix(szero)
}
# If no column names on surrogate candidates, set them as the column indices
if (is.null(colnames(sone))) {
colnames(sone) <- paste0("marker", 1:ncol(sone))
colnames(szero) <- paste0("marker", 1:ncol(szero))
}
# Validity checks
## Check same number of samples in primary response and surrogates
n0 <- length(yzero)
n1 <- length(yone)
if (nrow(szero) != n0) {
stop("szero does not have the same number of samples as yzero.")
}
if (nrow(sone) != n1) {
stop("sone does not have the same number of samples as yone.")
}
## if in paired mode, yone/sone must have exactly the same number of samples as yzero/szero
if (paired) {
if (length(yone) != length(yzero)) {
stop(
"Paired mode is requested but the number of samples in yone does not match that of yzero."
)
} else if (length(sone) != length(szero)) {
stop(
"Paired mode is requested but the number of samples in sone does not match that of szero."
)
}
}
## Check that either epsilon or power.want.s is specified
if (is.null(epsilon) & is.null(power.want.s)) {
stop("Must specify either epsilon or power.want.s.")
}
# Screen markers by applying surrogate test in parallel
## First define a function that we can then apply in parallel
.test_marker <- function(idx) {
args <- list(
yone = yone,
yzero = yzero,
sone = sone[, idx],
szero = szero[, idx],
alternative = alternative,
paired = paired,
power.want.s = power.want.s,
epsilon = epsilon
)
res <- do.call(test.surrogate.extension, args)
c(
delta = res$delta.estimate,
ci_lower = res$ci.delta[1],
ci_upper = res$ci.delta[2],
sd = res$sd.delta,
epsilon = res$epsilon.used,
p_unadjusted = res$p.delta
)
}
P <- ncol(sone)
raw_list <- pbmclapply(1:P, .test_marker, mc.cores = n.cores)
# Process the list results into a dataframe
results <- do.call(rbind, raw_list) %>%
as.data.frame(stringsAsFactors = FALSE) %>%
mutate(
marker        = colnames(sone),
p_adjusted    = p.adjust(p_unadjusted, method = p.correction)
) %>%
dplyr::select(marker,
epsilon,
delta,
sd,
ci_lower,
ci_upper,
p_unadjusted,
p_adjusted)
# Calculate the treatment effect on the primary response
u.y = SurrogateRank::test.surrogate(
yone = yone,
yzero = yzero,
sone = yone,
szero = yzero
)$u.y
results$u.y = u.y
results$u.s = u.y - results$delta
results$n = length(yone) + length(yzero)
results = results %>%
dplyr::select(marker,
epsilon,
n,
u.y,
u.s,
delta,
sd,
ci_lower,
ci_upper,
p_unadjusted,
p_adjusted)
# Retreive names of significant markers
significant_markers <- results %>%
filter(p_adjusted < alpha) %>%
pull(marker)
# Weight calculation
if (weight.mode == "inverse.delta") {
# If in inverse delta weight mode, we must account for the fact that we cannot invert 0
# Instead, we search for the next closest value and set the weight to this value
min.nonzero.delta = min(results %>%
filter(delta != 0) %>%
pull(delta) %>%
abs())
if (min.nonzero.delta == 0) {
min.nonzero.delta = 1
}
screening.weights <- results %>%
mutate(nonzero.delta = ifelse(delta != 0, delta, min.nonzero.delta)) %>%
mutate(weight = 1 / (abs(nonzero.delta))) %>%
dplyr::select(marker, weight)
} else if (weight.mode == "diff.epsilon") {
# In the diff.epsilon mode, we calculate the proportion of the distance between epsilon and 0 cut by delta
screening.weights <- results %>%
mutate(weight = (epsilon - abs(delta)) / epsilon) %>%
dplyr::select(marker, weight)
} else if (weight.mode == "none") {
# If no weights desired, set all to 1
screening.weights <- results %>%
mutate(weight = 1) %>%
dplyr::select(marker, weight)
}
if (normalise.weights) {
# If desired to normalise weights, divide by the max weight
max.weight = max(screening.weights$weight)
screening.weights = screening.weights %>%
mutate(weight_unstandardised = weight) %>%
mutate(weight = ifelse(marker %in% significant_markers, weight /
max.weight, NA))
} else if (!normalise.weights) {
screening.weights = screening.weights %>%
mutate(weight_unstandardised = weight)
}
# If desired that only significant weights be returned
if (!return.all.weights) {
screening.weights = screening.weights %>%
filter(marker %in% significant_markers)
}
# If desired that only significant screening results be returned
if (!return.all.screen) {
results <- results %>%
filter(marker %in% significant_markers)
} else {
results = results
}
return(
list(
screening.metrics   = results,
significant.markers = significant_markers,
screening.weights   = screening.weights
)
)
}
